#+TITLE:     command-line-utilities-leuven
#+AUTHOR:    Fabrice Niessen
#+EMAIL:     (concat "fniessen" at-sign "pirilampo.org")
#+DESCRIPTION: Shell extra utilities
#+KEYWORDS:  shell, script, bash
#+OPTIONS:   num:nil

Command-line-utilities-leuven is a collection of useful Shell scripts and
command-line tools that can simplify and automate tasks on the command line.
From file manipulation to system administration, these scripts cover a wide
range of tasks and can save you time and effort in your daily workflow.  Whether
you're a seasoned command-line user or just getting started, this repository has
something for everyone.

"Running XXX. This may take some time... done."

* Requirements

To be able to use the following commands, ensure that the following package is
installed on your system.

- [[https://github.com/docopt/docopts][docopts]] (~docopt~ for shell -- make beautiful CLI with ease)

  (I choose for the "with grep" syntax to have the help and version messages
  parsed from script *comments*, while avoiding having to source =docopts.sh=.)

- [[https://github.com/fniessen/wsl][wsl]] repository (for =bin/docopts=, needed in a WSL environment)

* Commands

** bak

Create a quick back-up copy of a file.

** f

Find directories or files matching a string and print their full file name.

** fd

Find directories matching a string and print their full file name.

** ff

Find files matching a string and print their full file name.

** find-duplicate-filenames

Find files with duplicate or conflicting names.

** find-duplicate-files

Search for duplicated files.

** find-recently-modified-files

Find all files modified in the last 7 days (including today).

** find-today-files

Find all files modified today in a specified directory or the current directory
(if none is specified), with the option to filter by file extension.

** remove-matching-lines-between-files

Remove lines that match any lines between two files.

** uncolor

Strip color sequences from the input text.

** swap

Swap the contents of two files.

** time-run-command-100

Run a command 100 times and print its average and median execution time.

* Contribute to command-line-utilities-leuven

** Best Practices

Bash scripting can be a powerful tool for automating tasks, but it's important
to follow best practices to ensure that your scripts are efficient, reliable,
and maintainable. Here are some best practices to keep in mind:

- Use =/usr/bin/env bash= in the shebang line (more portable way to reference the
  Bash interpreter).

- Use comments to explain what the code does.

- Use variables to store values used multiple times.

- Rename variables to follow lowercase naming convention.

- Enclose variables in double quotes to prevent word splitting and globbing.

- Use functions to avoid code repetition.

- Use ~set -u~ to treat unset variables as errors.

- Use ~set -e~ to exit immediately if a command fails.

- Use ~set -o pipefail~ to exit if any command in a pipeline fails.

- Use exit codes to indicate success or failure.

- Use ~printf~ instead of ~echo~ for better control over the output format.

- Add a period to the end of the error messages, so that it follows grammatical
  conventions.

- Use ~grep~ with the ~-w~ flag to match whole words.

- Use ~cut~ instead of ~awk~ to extract strings.

- Use ~uniq -d~ to find duplicated strings.

- Use ~sort -u~ to sort the output and remove duplicates from a list (instead of
  ~sort | uniq~).

- Use ~$()~ instead of backticks for command substitution.

- Use double brackets (~[[ ... ]]~) in Bash and Zsh scripting for more advanced
  conditional expressions, improved handling of variables (allows unquoted
  variables and word splitting), enhanced logical operators (~&&~, ~||~), and
  built-in pattern matching, providing a more powerful and flexible approach to
  conditionals compared to single brackets (~[ ... ]~).

- Use uppercase letters for variables that are intended to be constants and not
  changed during the script execution.

- Use lowercase letters for regular variables that can be modified during the
  script execution.

By following these best practices, you can write Bash scripts that are easier to
understand, maintain, and debug.

** Notes

Writing a Bash script in functions can make the code easier to reuse, more
readable, and easier to test and debug, which can save time and reduce the
likelihood of errors.

See https://unix.stackexchange.com/questions/313256/why-write-an-entire-bash-script-in-functions

** Code style

- Beautiful Bash: Let's make reading and writing bash scripts fun again!
  https://fr.slideshare.net/a_z_e_t/inpresentation

- Let's make better scripts
  https://downloads.cisofy.com/files/public/presentation-lets-make-better-scripts.pdf

- http://wiki.bash-hackers.org/scripting/style

- https://github.com/azet/community_bash_style_guide

- https://google-styleguide.googlecode.com/svn/trunk/shell.xml

  ~variable_name~ (preferred, ~variableName~ accepted) \\
  ~function_name~ \\
  ~CONSTANT_NAME~

** Shell formatter + checker

- https://github.com/mvdan/sh
- https://google.github.io/styleguide/shell.xml
- https://www.shellcheck.net/ (online checker!)

http://www.skybert.net/emacs/bash-linting-in-emacs/
