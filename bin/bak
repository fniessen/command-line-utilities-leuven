#!/usr/bin/env bash

#? bak, Time-stamp: <2025-08-07 Thu 11:46>
#? Copyright (C) 2020-2025 Fabrice Niessen. All rights reserved.
#?
#? License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>.
#? This is free software: you are free to change and redistribute it.
#? There is NO WARRANTY, to the extent permitted by law.

##? Usage: bak [options] FILE
##?
##? Create a quick back-up copy of a file.
##?
##? Arguments:
##?   FILE                          file to copy
##?
##? Options:
##?   -r, --rename                  rename the original file instead of making a copy
##?   -h, --help                    display this help and exit
##?   -V, --version                 display version information and exit
##?
##? Examples:
##?   bak core/main.c
##?   bak -r core/main.c

# BSD sysexits.h exit codes.
EX_OK=0                          # Success.
EX_DATAERR=65                    # Input data error (e.g., file comparison
                                 # failed).
EX_NOINPUT=66                    # Cannot open input.
EX_UNAVAILABLE=69                # Service unavailable (e.g., missing command).
EX_OSERR=71                      # System error (e.g., file operation failed).
EX_CANTCREAT=73                  # Output file creation skipped (e.g., user
                                 # declined overwrite or files identical).

# Set -uo pipefail for undefined variable check and pipeline failure propagation.
set -uo pipefail

# Define color and formatting variables using ANSI escape codes.
RESET=$'\e[0m'
BOLD=$'\e[1m'
GREEN=$'\e[32m'
RED=$'\e[31m'
YELLOW=$'\e[33m'
WHITE=$'\e[37m'
BGRED=$'\e[41m'
ERROR="${BOLD}${WHITE}${BGRED}"

# Check if 'colordiff' is installed, and use it for colorized output, fallback
# to 'diff'.
diff_cmd="diff"
if command -v colordiff > /dev/null 2>&1; then
    diff_cmd="colordiff"
fi

# Define function to check if a file exists, compare it, show differences if necessary,
# and prompt the user for overwrite.
confirm_overwrite_or_skip() {
    local source_file="$1"
    local backup_file="$2"

    if [[ -e "$backup_file" ]]; then
        if cmp -s "$source_file" "$backup_file"; then
            printf "Backup ${BOLD}$backup_file${RESET} already exists and is identical. No update needed.\n"
            return $EX_CANTCREAT
        else
            printf "\nDifferences between ${GREEN}${BOLD}$source_file${RESET} and ${RED}${BOLD}$backup_file${RESET}:\n\n"
            $diff_cmd -u "$backup_file" "$source_file"
            printf "\n"
            read -p "The file ${RED}${BOLD}$backup_file${RESET} already exists but differs. Overwrite it? (y/N) " confirm
            if [[ "$confirm" =~ ^[yY]$ ]]; then
                return $EX_OK
            else
                printf "Operation cancelled.\n"
                return $EX_CANTCREAT
            fi
        fi
    fi
    return $EX_OK
}

# Check if 'docopts' command is available.
if ! command -v docopts > /dev/null 2>&1; then
    printf >&2 "${ERROR}ERROR: 'docopts' command not found.${RESET}\n"
    exit $EX_UNAVAILABLE                # Service unavailable.
fi

# Extract help and version information from the script.
help=$(grep -E '^##\?' "$0" | cut -c 5-)
version=$(grep -E '^#\?' "$0" | cut -c 4-)

# Parse command-line arguments using docopts.
eval "$(docopts -h "$help" -V "$version" : "$@")" || exit $?

# Silence AI false positives: variables are set dynamically by docopts.
FILE="${FILE:-}"
rename=${rename:-false}

# Set -e to exit on non-zero command status.
set -e

# Define the backup file extension constant.
readonly BAK_EXTENSION="_bak"

# Extract the file extension and basename.
filename=$(basename -- "$FILE")
extension=""
if [[ ! "$filename" == *.* ]]; then
    extension=""
else
    extension=".${filename##*.}"
fi
basename="${filename%.*}"

# Define the backup file name with the path as prefix.
new_file="$(dirname -- "$FILE")/$basename$BAK_EXTENSION$extension"

# Check if file exists and is a regular file.
if [[ ! -f "$FILE" ]]; then
    printf >&2 "ERROR: Argument must be a regular file that exists.\n"
    exit $EX_NOINPUT
fi

# Copy or rename the file depending on the options used.
if [[ "$rename" == "true" ]]; then
    if confirm_overwrite_or_skip "$FILE" "$new_file"; then
        mv "$FILE" "$new_file" || exit $EX_OSERR
        printf "File renamed from ${BOLD}$FILE${RESET} to ${BOLD}$new_file${RESET}.\n"
    fi
else
    if confirm_overwrite_or_skip "$FILE" "$new_file"; then
        cp "$FILE" "$new_file" || exit $EX_OSERR
        printf "File copied from ${GREEN}${BOLD}$FILE${RESET} to ${RED}${BOLD}$new_file${RESET}.\n"
    fi
fi

# Exit with a success code.
exit $EX_OK
